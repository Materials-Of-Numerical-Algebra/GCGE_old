2018.10.14 liyu

在csr的test中，test_orth_ops.c是对于正交化成为ops的一个成员函数进行的尝试，可以考虑以后在kona中利用这种做法。
另外，test_orth_blas.c是对double型向量组进行正交化的函数，已通过blas进行加速，形式参数与test_orth_ops中的正交化函数类似。
之后在GCGE中应该内置blas库，进行编译，而且都利用宏BLASname(...), LAPACKname(...)进行调用，以防调用机器已有库时出现名字不统一
尤其是调用利用基于特定机器的blas lapack库
eigsol.c是对GCG核心函数的一个整理，整个代码流程和函数形式参数设定是最合理的。而且也是可以写到ops中的形式。

2018.10.12 liyu

hypre lobpcg中 HYPRE_lobpcg.c中对于tol有初始设置相对误差和绝对误差初始是1.0e-06

下面是lobpcg的收敛准则
175   notConverged = 0;
176   for ( i = 0; i < n; i++ ) {
177     if ( utilities_FortranMatrixValue( resNorms,  i + 1,  1 ) >
178          utilities_FortranMatrixValue( lambda,  i + 1,  1 )*rtol + atol
179          + DBL_EPSILON ) {
180       activeMask[i] = 1;
181       notConverged++; 
182     }
183     else 
184       activeMask[i] = 0;
185   }

2018.10.15 zhangning

修改需要的内存空间
在GCGE_WORKSPACE结构体中添加了

    GCGE_INT   V_size;
    GCGE_INT   V_tmp_size;
    GCGE_INT   CG_p_size;
    //GCGE_INT   CG_r_size;
    //GCGE_INT   RitzVec_size;

在gcge_workspace.c中添加

    GCGE_INT   V_size = max_dim_x + 2 * block_size;
    GCGE_INT   V_tmp_size = max_dim_x - nev + block_size;
    GCGE_INT   CG_p_size = block_size;

工作空间不再需要RitzVec，因此涉及到RitzVec的子函数都要修改

用到RitzVec的子函数: 
1. gcge_xpw.h与gcge_xpw.c中 ComputeX，修改形式参数为
    void GCGE_ComputeX(void **V, GCGE_DOUBLE *subspace_evec, void **X, 
        GCGE_INT size_X, GCGE_INT size_V,
        GCGE_OPS *ops, GCGE_WORKSPACE *workspace);
   gcge_eigsol.c中调用方式修改为
    GCGE_ComputeX(V, subspace_evec, evec, nev, workspace->dim_xpw, ops, workspace);
2. gcge_eigsol.c中MultiVecSwap，RitzVec替换为evec，交换的位置由dim_x改为nev,
    且计算结束后不再需要将RitzVec交换给evec
3. gcge_eigsol.c中调用CheckConvergence时给的参数由RitzVec替换为evec
4. gcge_cg.c中CG迭代的临时空间用到了workspace->RitzVec，改为使用workspace->evec
5. gcge_xpw.c中ComputeP时要把X重特征值的部分一起算,在线性组合与指针交换的地方修改向量个数
6. gcge_eigsol.c中span[X,W]中计算子空间矩阵前，先令dim_xp=0(第298行)
7. gcge_rayleighritz.c中计算子空间矩阵时,调用下面这个函数时,最后一个参数由workspace->V_tmp改为
    workspace->evec,因为第一次迭代中需要nev大小的向量空间
    void GCGE_ComputeSubspaceMatrixVTAW(void **V, void *A, GCGE_INT start_W, 
            GCGE_INT end_V, GCGE_DOUBLE *subspace_mat, GCGE_OPS *ops, void **workspace)

2018.10.16 zhangning
1. 在gcge_orthogonal.c中添加了GCGE_BOrthogonal，并将gcge_eigsol.c中对原GCGE_Orthogonal的调用形参做了修改(by hhxie)
2. 在gcge_cg.c中添加了块cg迭代(by hhxie)
    1) gcge_cg.c gcge_cg.h中添加了GCGE_BCG
    2) gcge_xpw.c 中 GCGE_ComputeW 做了修改, 改成多个W向量统一计算的格式

2018.10.17 zhangning
添加了SLEPc的调用接口, 包括 external/slepc, include/app/gcge_app_slepc.h, src/app/slepc, test/slepc

2018.10.18 zhangning
修改了gcge_rayleighritz.c中的GCGE_ComputeSubspaceMatrix,也修改了gcge_workspace.c中的subspace_dtmp的空间分配

2018.10.19 liyu
在求解特征值的程序中设置workspace->evec = solver->evec是不合适的，因为在BCG中还要调用workspace->evec
也就是说，BCG不能单独被调用，而且BCG的形式参数也很不好，并不是一个一般性的接口。
另外，即使用了hypre_seqvecinnerprod做为局部内积，好像BCG无论是原来的全局内积还是局部内积，都会收敛，很奇怪！
后来发现这样确实是对的，从理论上讲。

test_bcg.c在HYPRE下测试了BCG, 同时利用AMG做预条件子。
之所以lobpcg不精确求解残量方程，首先是它的正交化过程不能处理线性相关，且精度不能太高。
而GCGE精确求解线性方程可能会使得整个迭代次数减少，进而减少W正交化的时间。

所以，外部求解器起始就是一个预条件子，无论是否提供外部求解器，都会进行BCG, 这是性价比最高的调用方式

2018.10.21
1. 添加GCGE_CBOrthogonal时发现，ops->MultiVecLinearComb这个函数，线性组合的系数应该是从系数矩阵的第0个元素开始取才合理
   之前用到的这个函数，两个向量组都是从第0个开始用，所以对之前的使用没有影响
   1) 修改了gcge_ops.h中对于ops->MultiVecLinearComb的注释
   2) 修改了gcge_ops.c中的GCGE_Default_MultiVecLinearComb
2. 在gcge_orthogonal.c中添加了GCGE_CBOrthogonal函数，表示Classical Block Orthogonal,消息发送次数少，但会损失正交性
   使用A_5矩阵进行测试（1089*1089），1e-6可以达到, 1e-8无法达到
   可以在精度要求不高时，提高求解效率. 使用时可以根据需要修改重正交化次数
   1) 修改了gcge_orthogonal.c
   2) 修改了gcge_orthogonal.h
3. 修改了GCGE_ComputeSubspaceMatrix中子空间计算的部分
   1) 修改了gcge_rayleighritz.c

